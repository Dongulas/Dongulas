def vector_as_matrix(l):
    #Input: A is an n^2-vector l
    #Output: A n*n matrices A such that A[i,j]=l[m*i+j](the inverse of MatrixAsVector)
    n=len(l);
    m=sqrt(n);
    A=Matrix(m,m);
    for i in range(m):
        for j in range(m):
            A[i,j]=l[m*i+j];
    return A




def matrix_as_vector(A):
    #Input: A is an n*n matrix
    #Output: An n^2-vector whose entries are the entries of A
    n=len(A[0]);
    return vector([A[i,j] for i in range(n) for j in range(n)]);
    
    
    
    
def spanning_set_from_generating_set(T):
    #Input: T is a list of n x n Matrices that commute with each other
    #Output: S is a spanning set for the algebra generated by T
    # Minpolys is the list of minimal polynomials of elements of T
    n=len(T);
    Minpolys=[A.minpoly() for A in T]
    Degree=max([f.degree() for f in Minpolys])
    DegreeTuples=tuples(range(Degree),n)
    S=[prod([T[i]^r[i] for i in range(n)]) for r in DegreeTuples]
    return S




def in_span_check(A,L):
    # Input: A is an n*n matrix in S, L is a linearly independent subset of S
    # Output: If A is in the span of L, return true and the vector expressing A as a linear combination
    #         Otherwise, return false, 0
    Avec=matrix_as_vector(A);
    V=VectorSpace(QQ,len(Avec));
    W=V.subspace_with_basis(L);
    if Avec in W:
        return True, W.basis_matrix().solve_left(Avec)
    else:
        return False, W(0);




def basis_of_algebra(T,dim=0,spans=False):
    #Input: T is a list of n x n Matrices that commute with each other
    #Optional inputs: dim is the dimension of the algebra, spans is true if T spans the algebra(T linear independent set)
    #Output: L: list of basis elements as vectors, constructed as a subset of S=spanning_set_from_generatingSet(T)
    #Algorithm:
    #Construct a spanning set S of the algebra as monomials in T, with degree up to the degree of the minimal polynomial
    #Construct a linearly independent L subset of S, add more elements to enrich the linear-independent set L to get a basis
    S=spanning_set_from_generating_set(T);
    n=len(T);
    Minpolys=[A.minpoly() for A in T]
    Degree=max([f.degree() for f in Minpolys])
    DegreeTuples=tuples(range(Degree),n);
    L=[matrix_as_vector(T[0]^i) for i in range(Minpolys[0].degree())];
    if spans==True:
        L=[matrix_as_vector(T[i]) for i in range(n)]
    else:
        if dim>0:
            i=0;
            n1=len(L);
            while n1<dim:
                check,r=in_span_check(S[i],L)
                if check==False:
                    L.append(matrix_as_vector(S[i]))
                    n1=n1+1
                    i+=1
        else:
            for i in range(len(S)):
                check,r=in_span_check(S[i],L)
                if check==False:
                    L.append(matrix_as_vector(S[i]))
    B=[vector_as_matrix(l) for l in L]
    return B




def relation(T):
    #Input: L: basis of the algebra
    #Output: R: list of pairs [i,v] such that:
    #        -i is an index with S[i] not in L
    #        -v is a vector such that S[i]=sum([v[j]*L[j] for j in range(len(v))])
    #Using this to find the polynomial in the ideal
    n=len(T);
    DegreeTuples=tuples(range(3),n)
    L=[matrix_as_vector(t) for t in T]
    S=[prod([T[i]^r[i] for i in range(n)]) for r in DegreeTuples]
    R=[];
    for i in range(len(S)):
        check,r=in_span_check(S[i],L);
        R.append([i,r])
    return R




def make_ideals(T,dim=0,spans=False):
    #Input: T is a list of n x n Matrices that commute with each other
    #Optional inputs: dim is the dimension of the algebra, spans is true if T spans the algebra(T linear independent set)
    #Output: I: an ideal of polynomial ring such that A is isomorphic to K[x_0,\cdots,x_n]/I(suppose dim A=n)
    I=0;
    I1=[];
    l=[];
    a=[];
    b=0;
    f=0;
    g=0;
    s=[];
    L=basis_of_algebra(T,dim,spans);
    R=relation(L)
    n=len(L);
    Minpolys=[A.minpoly() for A in L]
    DegreeTuples=tuples(range(3),n)
    K = PolynomialRing(QQ, ['x%s'%i for i in range(n)])
    X=K.gens();
    S=[prod([X[i]^r[i] for i in range(n)]) for r in DegreeTuples];
    for i in range(n):
        l=Minpolys[i].coefficients();
        s=Minpolys[i].exponents();
        g=sum(l[j]*X[i]^s[j] for j in range(len(l)));
        I1.append(g);
    for r in R:
        a=r[1];
        b=r[0];
        f=sum(a[j]*X[j] for j in [0..len(a)-1])-S[b];
        I1.append(f);
    I=I1*K
    return I




def make_multiplication_table(L):
    #Input: A basis L of a finite dimensional algebra
    #Output: A multiplication table
    M=[]
    n=len(L);
    m=len(matrix_as_vector(L[0]));
    C=Matrix(n,m);
    for i in range(n):
        C[i]=matrix_as_vector(L[i]);
    for i in range(n):
        D=Matrix(n,n);
        for j in range(n):
            N=L[i]*L[j];
            l1=matrix_as_vector(N);
            D[j]=C.solve_left(l1);
        M.append(D);
    return M
 
 
 
 
#example for a list of commuting matrices(ps. "commuting" is very important here)
A=Matrix([[1,0],[0,2]])
B=Matrix([[2,0],[0,5]])
D=Matrix([[2,0],[0,7]])
L=basis_of_algebra([A,B,C])
'Groebner basis of the ideal I'
make_ideals([A,B,D]).groebner_basis()#groebner basis of I
'Mutliplication table of the algebra'
make_multiplication_table(L)




#apply to Hecke algebra T_2(11)(weight 2, level 11)
M=ModularForms(11,2);
bound=M.hecke_bound();
dim=M.dimension()
Ts=[M.hecke_matrix(n) for n in range(1,bound+1)];
L1=basis_of_algebra(Ts)
'Mutliplication table of the Hecke algebra'
make_multiplication_table(L1)
'Groebner basis of the ideal I'
make_ideals(Ts).groebner_basis()

